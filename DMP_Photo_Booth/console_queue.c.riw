#include "console_queue.h"

/**
 * Locks the queue mutex
 */
#define CQ_MUTEX_LOCK (g_mutex_lock(&dmp_pb_cq_mutex))

/**
 * Unlocks the queue mutex
 */
#define CQ_MUTEX_UNLOCK (g_mutex_unlock(&dmp_pb_cq_mutex))

struct queue_node
{
	gchar * data;
	struct queue_node * next;
};

struct console_queue
{
	struct queue_node * front;
	struct queue_node * back;
};

static gboolean cq_is_initialized = false;
static struct console_queue cq;
static GMutex dmp_pb_cq_mutex;

int dmp_pb_console_queue_init()
{
	CQ_MUTEX_LOCK;
	cq.back = NULL;
	cq.front = NULL;
	cq_is_initialized = true;
	CQ_MUTEX_UNLOCK;
}

gboolean dmp_pb_console_queue_is_empty()
{
	return (cq.front == NULL && cq.back == NULL);
}

/**
 * creates and returns a new queue node
 * @param message the string to insert into the node
 * @return a pointer to a struct queue_node. The caller is responsible for
 * memory management of this pointer
 */
static struct queue_node * dmp_pb_console_queue_node_new(gchar * message)
{
	struct queue_node * working = malloc(sizeof(struct queue_node));
	
	if (message == NULL) 
	{
		working->data = malloc(strlen(""));
		strcpy(working->data, "");
	}
	else
	{
		working->data = malloc(strlen(message) + 1);
		strcpy(working->data, message);
	}
	working->next = NULL;
	return working;
}

gint dmp_pb_console_queue_push(gchar * message)
{
	gint return_value = DMP_PB_SUCCESS;
	if (!cq_is_initialized) return DMP_PB_CONSOLE_QUEUE_NOT_INITIALIZED;
	CQ_MUTEX_LOCK;
	
	if (dmp_pb_console_queue_is_empty())
	{
		cq.front = dmp_pb_console_queue_node_new(message);
		cq.back = cq.front;
	}
	else
	{
		cq.back->next = dmp_pb_console_queue_node_new(message);
		cq.back = cq.back->next;
	}
	
	CQ_MUTEX_UNLOCK;
	return return_value;
}

gchar * dmp_pb_console_queue_pop()
{
	gchar * return_value = NULL;
	if (!cq_is_initialized) return return_value;
	if (dmp_pb_console_queue_is_empty()) return return_value;
	
	CQ_MUTEX_LOCK;
	
	struct queue_node * working = cq.front;
	return_value = working->data;
	cq.front = working->next;
	free(working);
	if (cq.front == NULL) cq.back = NULL;
	
	CQ_MUTEX_UNLOCK;
	return return_value;
}

gchar * dmp_pb_console_queue_peek()
{
	gchar * return_value = NULL;
	if (!cq_is_initialized) return return_value;
	if (dmp_pb_console_queue_is_empty()) return return_value;

	CQ_MUTEX_LOCK;
	
	return_value = cq.front->data;
	
	CQ_MUTEX_UNLOCK;
	return return_value;
}

gint dmp_pb_console_queue_finalize()
{
	if (!cq_is_initialized) return DMP_PB_CONSOLE_QUEUE_NOT_INITIALIZED;
	
	struct queue_node * working = NULL;
	
	CQ_MUTEX_LOCK;
	
	while (cq.front != NULL)
	{
		working = cq.front;
		cq.front = working->next;
		free(working->data);
		free(working);
	}
	
	cq_is_initialized = false;
	
	CQ_MUTEX_UNLOCK;
	return DMP_PB_SUCCESS;
}